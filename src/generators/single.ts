import {
  createDirectory,
  writeFile,
  getProjectPath,
  logStep,
  logSuccess,
  logInfo,
  initializeGit,
  type GeneratorConfig,
  capitalize,
} from "@/utils/helpers.js";
import { generateElysiaBackend } from "@/generators/backends/elysia.js";
import { generateFastAPIBackend } from "@/generators/backends/fastapi.js";
import { generateAstroFrontend } from "@/generators/frontends/astro.js";
import { generateSvelteFrontend } from "@/generators/frontends/svelte.js";
import { generateNextJSFrontend } from "@/generators/frontends/nextjs.js";

export async function generateSingle(config: GeneratorConfig): Promise<void> {
  const projectPath = getProjectPath(config.projectName);

  logStep(`Creating single project at ${projectPath}`);
  await createDirectory(projectPath);

  const docsPath = `${projectPath}/Docs`;
  await createDirectory(docsPath);

  await generateGitIgnore(projectPath);
  await generateReadme(projectPath, config);
  await generateAgentsMd(projectPath, config);
  await generateLicense(projectPath, config);
  await generateEnvExample(projectPath);

  if (config.backend?.framework) {
    await createDirectory(`${projectPath}/src`);
    switch (config.backend.framework) {
      case "elysia":
        await generateElysiaBackend(projectPath, config);
        break;
      case "fastapi":
        await generateFastAPIBackend(projectPath, config);
        break;
    }
  } else if (config.frontend?.framework) {
    await createDirectory(`${projectPath}/src`);
    switch (config.frontend.framework) {
      case "astro":
        await generateAstroFrontend(projectPath, config);
        break;
      case "svelte":
        await generateSvelteFrontend(projectPath, config);
        break;
      case "nextjs":
        await generateNextJSFrontend(projectPath, config);
        break;
    }
  }

  await createDirectory(`${docsPath}/Feature`);
  await createDirectory(`${docsPath}/DatabaseSetup`);
  await generateSchemaDocs(docsPath, config);

  logSuccess(`Project created at ${config.projectName}`);
  logSuccess("Docs folder created");

  if (config.git) {
    await initializeGit(projectPath);
  }

  if (config.backend?.framework) {
    const backendInstallCmd =
      config.backend.framework === "fastapi" && config.backend.packageManager === "venv"
        ? `chmod +x setup.sh && ./setup.sh`
        : config.backend.packageManager === "venv" || config.backend.packageManager === "pip"
          ? `pip install -r requirements.txt`
          : `${config.backend.packageManager} install`;
    const backendRunCmd =
      config.backend.framework === "fastapi"
        ? `python src/main.py`
        : `${config.backend.packageManager} run dev`;

    logInfo("\nðŸ“¦ Next steps:");
    logInfo(`  cd ${config.projectName}`);
    logInfo(`  ${backendInstallCmd}`);
    logInfo(`  ${backendRunCmd}`);
  } else if (config.frontend?.framework) {
    logInfo("\nðŸ“¦ Next steps:");
    logInfo(`  cd ${config.projectName}`);
    logInfo(`  ${config.frontend.packageManager} install`);
    logInfo(`  ${config.frontend.packageManager} run dev`);
  }
}

async function generateGitIgnore(projectPath: string): Promise<void> {
  const content = `# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/
*.lcov
playwright-report/
playwright/.cache/

# Next.js
.next/
out/

# Production
build/
dist/

# Misc
.DS_Store
*.pem

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Vercel
.vercel

# TypeScript
*.tsbuildinfo

# Astro
.astro/

# Svelte
.svelte-kit/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
*.egg-info/
.eggs/
dist/
build/

# IDE
.idea/
.vscode/
*.swp
*.swo
*~
`;

  await writeFile(`${projectPath}/.gitignore`, content);
  logSuccess(".gitignore created");
}

async function generateReadme(projectPath: string, config: GeneratorConfig): Promise<void> {
  let content = `# ${config.projectName}

This project was generated by [Phos](https://github.com/yourusername/phos).

## Getting Started

`;

  if (config.backend?.framework) {
    content += `\`\`\`bash
${
  config.backend!.packageManager === "venv" || config.backend!.packageManager === "pip"
    ? "pip install -r requirements.txt"
    : `${config.backend!.packageManager} install`
}
${config.backend!.framework === "fastapi" ? "python src/main.py" : `${config.backend!.packageManager} run dev`}
\`\`\``;
  } else if (config.frontend?.framework) {
    content += `\`\`\`bash
${config.frontend!.packageManager} install
${config.frontend!.packageManager} run dev
\`\`\``;
  }

  content += `

## Tech Stack
`;

  if (config.backend?.framework) {
    content += `- Framework: ${config.backend!.framework}
- Package Manager: ${config.backend!.packageManager}
- TypeScript: ${config.backend!.typescript ? "Yes" : "No"}
- ESLint: ${config.backend!.eslint ? "Yes" : "No"}
- Prettier: ${config.backend!.prettier ? "Yes" : "No"}
`;
  } else if (config.frontend?.framework) {
    content += `- Framework: ${config.frontend!.framework}
- Package Manager: ${config.frontend!.packageManager}
- TypeScript: ${config.frontend!.typescript ? "Yes" : "No"}
- ESLint: ${config.frontend!.eslint ? "Yes" : "No"}
- Prettier: ${config.frontend!.prettier ? "Yes" : "No"}
- CSS Framework: ${config.frontend!.cssFramework}
- UI Components: ${config.frontend!.uiComponents}
- Testing: ${config.frontend!.testing}
`;
  }

  await writeFile(`${projectPath}/README.md`, content);
  logSuccess("README.md created");
}

async function generateAgentsMd(projectPath: string, config: GeneratorConfig): Promise<void> {
  const projectName = config.projectName;

  const content = `# AGENTS Guidelines for This Repository

## Project Name: ${projectName}

This project was generated by [Phos](https://github.com/yourusername/phos).

### Core Features:
- Fast and interactive project setup
- Modern framework support
- Type-safe configurations
- ESLint and Prettier support
- Testing infrastructure

### Project Structure:
\`\`\`
${projectName}/
â”œâ”€â”€ src/              # Source code
â”œâ”€â”€ Docs/              # Documentation
â”‚   â”œâ”€â”€ Feature/       # Feature documentation
â”‚   â””â”€â”€ DatabaseSetup/ # Database scripts
â”œâ”€â”€ README.md          # Project documentation
â”œâ”€â”€ .gitignore         # Git ignore rules
â””â”€â”€ LICENSE            # License file
\`\`\`

### Development Workflow:
1. Make changes to source code in \`src/\`
2. Update documentation in \`Docs/\` as needed
3. Test changes thoroughly
4. Commit with clear, descriptive messages

### Agent Guidelines:
- Follow existing code style and conventions
- Add proper type annotations where applicable
- Write tests for new features
- Update README.md for major changes
- Use clear, descriptive variable/function names
- Comment complex logic for maintainability

### Best Practices:
- Run linter before committing (ESLint, Prettier)
- Test on different environments before deployment
- Keep dependencies updated and secure
- Write clear, concise commit messages
- Review pull requests thoroughly before merging

### Troubleshooting:
- Check documentation first
- Review recent changes if issues arise
- Use version control to revert problematic changes
- Ask for help in team channels when stuck
`;

  await writeFile(`${projectPath}/AGENTS.md`, content);
  logSuccess("AGENTS.md created");
}

async function generateLicense(projectPath: string, config: GeneratorConfig): Promise<void> {
  const year = new Date().getFullYear();
  const content = `MIT License

Copyright (c) ${year} ${config.projectName}

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
`;

  await writeFile(`${projectPath}/LICENSE`, content);
  logSuccess("LICENSE created");
}

async function generateEnvExample(projectPath: string): Promise<void> {
  const content = `# Database
DB_HOST=localhost
DB_NAME=your_db_name
DB_USER=postgres
DB_PASSWORD=postgres
DB_PORT=5433

# URLs
FRONTEND_BASE_URL=http://localhost:4200
BACKEND_BASE_URL=http://localhost:4100

# JWT Configuration for rest API
JWT_SECRET=your-super-secret-jwt-key-change-in-production
JWT_EXPIRES_IN=60m

# Encryption
ENCRYPTION_SALT=your-super-secret-salt-change-in-production

# API Keys
X_API_KEY=1234
`;

  await writeFile(`${projectPath}/env.example`, content);
  logSuccess("env.example created");
}

async function generateSchemaDocs(docsPath: string, config: GeneratorConfig): Promise<void> {
  const projectName = config.projectName;
  const content = `# ${projectName} Database Schema

## Table of Contents

- [${projectName} Database Schema](#${projectName.toLowerCase()}-database-schema)
  - [Table of Contents](#table-of-contents)
  - [Overview](#overview)
  - [Core Entities](#core-entities)
    - [Entity Name](#entity-name)
  - [Entity Relationships](#entity-relationships)
  - [SQL Schema](#sql-schema)
    - [Create Tables](#create-tables)
  - [Sample Data](#sample-data)
  - [Data Types Notes](#data-types-notes)
  - [Migration Notes](#migration-notes)

---

## Overview

This document describes the complete database schema for ${projectName}, including all entities, relationships, and sample data.

---

## Core Entities

### Entity Name

| Column      | Type     | Nullable | Description                        |
| ----------- | -------- | -------- | ---------------------------------- |
| id          | int      | No       | Primary key, auto-incremented ID   |
| uuid        | string   | No       | Unique identifier                  |
| column_name | str      | Yes/No   | Description of column              |
| created_at  | datetime | No       | Record creation timestamp (UTC)    |
| updated_at  | datetime | Yes      | Record last update timestamp (UTC) |

---

## Entity Relationships

\`\`\`
table1 (1) â”€â”€â”€â”€ (many) table2
table3 (many) â”€â”€â”€â”€ (1) table4
\`\`\`

---

## SQL Schema

### Create Tables

For PostgreSQL deployment, use the following schema:

\`\`\`sql
-- Drop tables if they exist (for clean setup)
DROP TABLE IF EXISTS child_table;
DROP TABLE IF EXISTS parent_table;

-- Parent table
CREATE TABLE parent_table (
    id SERIAL PRIMARY KEY,
    uuid TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Child table
CREATE TABLE child_table (
    id TEXT PRIMARY KEY,
    parent_id TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES parent_table(uuid)
);

-- Add foreign key constraints if needed
ALTER TABLE child_table ADD CONSTRAINT fk_child_parent FOREIGN KEY (parent_id) REFERENCES parent_table(uuid);

-- Performance indexes
CREATE INDEX idx_parent_table_uuid ON parent_table(uuid);
CREATE INDEX idx_child_table_parent_id ON child_table(parent_id);
CREATE INDEX idx_child_table_created_at ON child_table(created_at);
\`\`\`

---

## Sample Data

\`\`\`sql
-- Insert sample data for parent table
INSERT INTO parent_table (uuid, name, description, created_at)
VALUES ('550e8400-e29b-41d4-a716-4466554400000', 'Sample Name', 'Sample description', CURRENT_TIMESTAMP);

-- Insert sample data for child table
INSERT INTO child_table (id, parent_id, content, created_at, updated_at)
VALUES ('6ba7b810-9dad-11d1-80b4-00c04fd430c8', '550e8400-e29b-41d4-a716-4466554400000', 'Sample content', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP);
\`\`\`

---

## Data Types Notes

- **UUID**: Stored as TEXT for simplicity
- **Arrays**: Stored as native PostgreSQL arrays (e.g., text[])
- **JSON**: Stored as JSONB for PostgreSQL (or TEXT for SQLite)
- **Boolean**: Stored as BOOLEAN for PostgreSQL (or INTEGER 0/1 for SQLite)
- **Decimal**: Stored as DECIMAL for precision calculations
- **Datetime**: Stored as TIMESTAMP with CURRENT_TIMESTAMP defaults

---

## Migration Notes

When deploying to production:

1. Consider using PostgreSQL for better JSON support and performance
2. Add proper UUID generation in application code
3. Implement database migrations for schema changes
4. Add database constraints and triggers as needed
5. Run \`ALTER TABLE\` statements for schema additions
6. Test migrations on staging environment before production
`;

  await writeFile(`${docsPath}/Schema.md`, content);
  logSuccess("Schema.md created");
}
